from sklearn.linear_model import LogisticRegression
from sklearn.svm import SVC
from sklearn.metrics import accuracy_score
import pandas as pd
import numpy as np

# --- Dados de Treino e Teste (Assumidos como Padronizados e Prontos) ---
# NOTE: Este bloco simula o X_train, X_test, y_train, y_test obtidos no passo 1.2.
# Para um código executável, você deve garantir que estas variáveis estejam definidas.
# Usarei variáveis dummy para garantir que o código funcione no ambiente atual,
# mas o código de treinamento assume que os dados processados existem.

# Placeholder for processed data (assuming 569 samples total, 30 features)
# if not defined from previous steps, run the setup code first!

# Definir os shapes de X_train/X_test e Y_train/Y_test
n_samples = 569
n_features = 30
test_size = 0.3 # 171 samples
train_size = n_samples - test_size # 398 samples

# Criação de dados dummy (se necessário, substitua pelas suas variáveis reais)
# X_train = np.random.rand(398, n_features)
# X_test = np.random.rand(171, n_features)
# Y_train = np.random.randint(0, 2, 398)
# Y_test = np.random.randint(0, 2, 171)

# Se você rodou o código do passo 1.2, as variáveis X_train, X_test, Y_train, Y_test já devem estar prontas.

# Dicionário para armazenar modelos treinados
models = {}
# Dicionário para armazenar resultados de acurácia
results = {}

print("--- 1. Inicializando Modelos ---")

# 1. Regressão Logística
models['LogisticRegression'] = LogisticRegression(max_iter=500, random_state=42)

# 2. SVM Linear
models['SVC_Linear'] = SVC(kernel='linear', random_state=42)

# 3. SVM Polinomial (Grau 2)
models['SVC_Poly_Degree_2'] = SVC(kernel='poly', degree=2, random_state=42)

# 4. SVM Polinomial (Grau 3)
models['SVC_Poly_Degree_3'] = SVC(kernel='poly', degree=3, random_state=42)

print(f"Total de modelos a serem treinados: {len(models)}")
print("-" * 50)

# --- 2. Treinamento e Avaliação em Loop ---

for name, model in models.items():
    print(f"Treinando modelo: {name}...")

    # 2.1. Treinamento
    model.fit(X_train, Y_train) # Corrigido de y_train para Y_train

    # 2.2. Previsão no conjunto de Teste
    y_pred = model.predict(X_test)

    # 2.3. Avaliação da Acurácia
    accuracy = accuracy_score(Y_test, y_pred) # Corrigido de y_test para Y_test
    results[name] = accuracy

    print(f"-> Treinamento concluído. Acurácia no Teste: {accuracy:.4f}")

    # 2.4. Salvando o modelo na memória (no dicionário 'models')
    # O modelo treinado já está salvo no dicionário 'models'
    print(f"-> Modelo {name} salvo no dicionário 'models'.")
    print("-" * 50)


# --- 3. Resultados Consolidados ---

print("--- 3. Resultados Consolidados de Acurácia ---")

# Criar um DataFrame para visualização clara
results_df = pd.DataFrame(results.items(), columns=['Modelo', 'Acurácia'])
results_df = results_df.sort_values(by='Acurácia', ascending=False).reset_index(drop=True)

print(results_df.to_markdown(index=False))

# O modelo mais acurado
best_model_name = results_df.iloc[0]['Modelo']
best_accuracy = results_df.iloc[0]['Acurácia']

print(f"\n✅ O modelo com maior acurácia no conjunto de teste é o **{best_model_name}** com **{best_accuracy:.4f}**.")
